# Performance QA — 성능 병목 없이 부드럽게 실행되는가

게임의 핵심 루프가 목표 프레임레이트를 유지하며, 메모리가 안정적으로 관리되는지를 판단한다.

---

## 우려 유형

### 1. 핫패스 병목 (Hot Path Bottleneck)
- **관점:** 게임의 핵심 루프(매 프레임 실행되는 경로)에 비용이 높은 연산이 있는가?
- **살펴볼 곳:** Update/LateUpdate/FixedUpdate의 실행 내용. 특히 플레이어 수, 적 수, 오브젝트 수에 비례하여 비용이 증가하는 로직
- **판단 기준:** 매 프레임 실행되는 코드에서 O(n²) 이상의 연산, 매 프레임 탐색/생성/파괴가 있는 경우. 게임의 **규모**(동시 활성 엔티티 수)를 고려하여 판단

### 2. GC 스파이크 (GC Spike)
- **관점:** 가비지 컬렉션이 발생하여 눈에 띄는 프레임 드랍이 생기는 시점이 있는가?
- **살펴볼 곳:** 핫패스에서 힙 할당을 유발하는 코드 (new, string 연결, LINQ, 박싱). 대량 오브젝트 생성/파괴 시점
- **판단 기준:** 핫패스에서 매 프레임 할당이 발생하거나, 특정 시점(전투 시작, 씬 전환)에 대량 할당이 집중되는 경우

### 3. 리소스 누수 (Resource Leak)
- **관점:** 시간이 지남에 따라 메모리가 계속 증가하는 경로가 있는가?
- **살펴볼 곳:** Material/Texture2D/RenderTexture 생성 후 Destroy 누락. Addressables Release 누락. 이벤트 구독 해지 누락
- **판단 기준:** 리소스 생성과 해제가 짝을 이루지 않는 코드 경로. 특히 반복적으로 호출되는 경로에서의 누수

### 4. 로딩 시간 (Load Time)
- **관점:** 씬 전환, 게임 시작, 특정 기능 진입 시 플레이어가 체감할 만한 대기가 있는가?
- **살펴볼 곳:** 동기 씬 로드, 대량 에셋 동기 로드, Start/Awake에서의 무거운 초기화
- **판단 기준:** 씬 로드가 동기적이거나, 초기화에서 대량 데이터를 파싱/로드하는 경우

### 5. 렌더링 과부하 (Rendering Overhead)
- **관점:** 동시에 너무 많은 것을 그려서 GPU가 병목이 되는가?
- **살펴볼 곳:** 동시 활성 오브젝트 수, 투명 오버드로우, 셰이더 복잡도, 배칭 가능성
- **판단 기준:** 게임의 최대 동시 활성 오브젝트/이펙트 수에서 드로우콜이 과도한 경우

### 6. 비효율적 자원 사용 (Resource Inefficiency)
- **관점:** 풀링이나 캐싱으로 쉽게 개선할 수 있는 반복 생성/파괴가 있는가?
- **살펴볼 곳:** 전투 이펙트, 총알, UI 아이템 등 빈번히 생성/파괴되는 오브젝트. 반복 호출되는 GetComponent/Find
- **판단 기준:** 게임의 특성상 빈번하게 호출되는 부분에서 캐싱/풀링이 없는 경우

---

## 코드 검증 관점

- 게임의 **핵심 루프**를 파악한 뒤, 그 루프 안에서 실행되는 코드의 **비용**을 분석
- 리소스 생성 코드를 추적하여 **해제 경로가 항상 실행되는지** 확인
- 씬 로드/초기화 경로에서 **동기 작업의 볼륨** 추정
- 게임 규모(최대 엔티티 수, 최대 이펙트 수)를 고려한 **최악의 경우 비용** 추정

---

## 런타임 검증 관점

- FPS, 메모리, GC 할당을 `execute_code`로 실시간 모니터링
- 게임의 부하가 높은 시점(전투, 대량 생성)에서 프레임 드랍 측정
- 장시간 플레이 시뮬레이션으로 메모리 증가 추세 확인
- 씬 전환 소요 시간 측정
