---
name: codebase-inquiry
description: 익숙하지 않은 코드베이스에서 구조적 변경이나 새로운 기능 구현을 시작하기 전, 개발자의 설계 의도를 파악하기 위한 대화형 워크플로우. 이해관계자 여부를 확인한 뒤 모호한 구현에 대해 질문한다. Use before making structural changes or implementing new features in an unfamiliar codebase. Do NOT use for simple bug fixes, minor edits, or read-only exploration.
---

# 코드베이스 탐색 워크플로우

익숙하지 않은 코드베이스에서 구조적 변경이나 새 기능 구현에 착수하기 전, 개발자의 설계 의도를 파악하고 모호한 부분을 질문하는 워크플로우.

## 핵심 원칙

1. **추측하지 않는다.** 코드에서 확인된 사실만을 기반으로 질문을 구성한다. 의도를 짐작하여 설명하지 않는다.
2. **맥락을 먼저 파악한다.** 질문하기 전에 프로젝트 구조, 의존성, 아키텍처 패턴을 충분히 탐색한다.
3. **질문은 구체적으로 한다.** "이 코드가 뭔가요?"가 아니라 "이 클래스가 X 패턴 대신 Y 방식을 선택한 이유가 있나요?"처럼 코드 근거를 포함한 질문을 한다.
4. **사용자의 역할에 맞게 대응한다.** 이해관계자/기여자에게는 깊은 의도 질문을, 비기여자에게는 원래 요청에 집중한다.
5. **토큰을 절약한다.** 파일 전체를 읽지 않고 심볼 개요와 구조 탐색으로 시작한다. 코드 본문은 모호한 부분이 발견된 심볼만 선택적으로 읽는다.

---

## Step 1: 이해관계자 확인

구조적 변경이나 새 기능 구현을 위해 코드베이스를 편집하려는 의도가 확인되면, 작업 전에 먼저 질문한다:

> "이 코드베이스의 관련자(이해관계자/기여자)이신가요?"

응답에 따라 경로를 결정한다:

- **"예" (기여자)** → 아래 "기여자 경로" 진행
- **"아니오" (비기여자)** → 아래 "비기여자 경로" 진행

---

## 기여자 경로: 코드베이스 심층 분석

### Step 2: 코드베이스 규모 판단 및 분석 깊이 결정

프로젝트 루트 구조를 탐색하여 규모를 체감한 뒤, 분석 깊이를 적절히 조절한다.

**점진적 탐색 원칙:**
1. 디렉토리 구조부터 파악한다 (레이아웃, 설정 파일, 빌드 시스템)
2. 핵심 진입점을 식별한다 (main, bootstrap, entry point)
3. `get_symbols_overview`로 심볼 목록만 먼저 확인한다 — 파일 전체를 읽지 않는다
4. 모호한 부분이 의심되는 심볼만 `find_symbol(include_body=True)`로 선택적으로 읽는다
5. 프로젝트가 크다면 한 번에 모든 모듈을 분석하지 않고, 핵심 모듈부터 시작한 뒤 사용자 피드백에 따라 범위를 확장한다

사용자가 특정 범위를 지정한 경우 해당 범위에 집중한다.

### Step 3: 모호한 구현 식별

코드베이스를 탐색하면서 아래 "모호한 구현 식별 기준"에 해당하는 코드를 수집한다. 각 항목에 대해 다음을 기록한다:

- **위치**: 파일 경로 + 심볼명 (클래스, 메서드 등)
- **관찰**: 코드에서 확인된 사실 (무엇이 구현되어 있는지)
- **모호한 점**: 무엇이 불명확한지 (왜 이렇게 했는지, 다른 선택지와의 비교)
- **우선순위**: 아키텍처 결정 > 비즈니스 로직 > 구현 세부사항

### Step 4: 개발 의도 질문 생성

수집된 모호한 구현에 대해 아래 "효과적인 질문 작성 가이드라인"을 따라 질문을 생성한다.

질문은 다음 형식으로 사용자에게 제시한다:

```
## 코드베이스 분석 질문

### 아키텍처 관련
1. `[파일경로]`의 `[심볼명]` — [관찰 내용]. [질문]
2. ...

### 비즈니스 로직 관련
1. `[파일경로]`의 `[심볼명]` — [관찰 내용]. [질문]
2. ...

### 구현 세부사항
1. `[파일경로]`의 `[심볼명]` — [관찰 내용]. [질문]
2. ...
```

한 번에 너무 많은 질문을 하지 않는다. 소화할 수 있는 양만 제시하고, 사용자 응답을 받은 후 추가 질문이 있으면 이어서 한다.

### Step 5: 분석 결과 정리

사용자의 답변을 반영하여 코드베이스 이해도를 정리한다:

```
## 코드베이스 분석 결과

### 프로젝트 개요
- [프로젝트 목적 및 도메인]

### 아키텍처
- [파악된 아키텍처 패턴과 설계 의도]

### 핵심 시스템
- [주요 모듈/시스템 목록과 역할]

### 확인된 설계 의도
- [질문을 통해 파악된 개발자의 의도적 선택들]

### 추가 확인 필요 사항
- [아직 불명확한 부분, 추가 질문이 필요한 영역]
```

---

## 비기여자 경로: 원래 요청 진행

### Step 2: 요청 확인 및 진행

비기여자임을 확인한 후:

1. 원래 요청 내용을 다시 확인한다
2. "코드베이스에 대한 깊은 의도 파악 질문 없이, 요청하신 내용을 바로 진행하겠습니다. 진행할까요?"라고 확인한다
3. 사용자가 동의하면 원래 요청을 그대로 수행한다

비기여자라도 분석 과정에서 명백히 이해가 안 되는 부분이 있으면 간단히 질문할 수 있다. 단, 개발 의도나 설계 결정에 대한 심층 질문은 하지 않는다.

---

## 모호한 구현 식별 기준

다음 패턴이 발견되면 모호한 구현으로 분류한다:

### 네이밍 불일치
- 메서드명과 실제 동작이 다른 경우 (예: `Initialize()`가 초기화 외의 작업도 수행)
- 변수명이 저장하는 데이터를 정확히 반영하지 않는 경우
- 유사한 이름의 클래스/메서드가 여러 개 존재하며 역할 구분이 불명확한 경우

### 비관습적 패턴
- 프레임워크/언어의 일반적 관용구와 다른 방식을 사용하는 경우
- 디자인 패턴이 일부만 적용되거나 변형된 경우
- 의존성 방향이 일반적인 레이어 구조를 거스르는 경우

### 주석 부재 또는 불일치
- 복잡한 로직에 주석이 없는 경우
- 주석 내용과 실제 코드 동작이 일치하지 않는 경우
- TODO/HACK/FIXME 주석이 남아있는 경우

### 다중 해석 가능성
- 코드가 여러 가지 목적으로 해석될 수 있는 경우
- 조건 분기가 복잡하여 의도된 동작을 특정하기 어려운 경우
- 매직 넘버, 하드코딩된 값의 의미가 불분명한 경우

### 구조적 의문
- 특정 클래스/모듈이 과도한 책임을 지는 경우 (God Object 의심)
- 사용되지 않는 코드가 남아있는 경우 (의도적 보존인지 삭제 누락인지)
- 추상화 수준이 일관되지 않는 경우

---

## 효과적인 질문 작성 가이드라인

### 질문 구조

모든 질문은 다음 3요소를 포함한다:

1. **관찰** — 코드에서 확인한 사실 ("X 클래스가 Y 방식으로 구현되어 있습니다")
2. **대안 제시** — 일반적으로 기대되는 방식 ("보통은 Z 패턴을 사용하는데")
3. **의도 질문** — 선택 이유에 대한 질문 ("Y 방식을 선택한 특별한 이유가 있나요?")

### 좋은 질문 예시

- "`UserService`가 직접 DB 쿼리를 실행하고 있습니다. Repository 패턴 대신 직접 접근을 선택한 이유가 있나요? (예: 성능, 단순성 등)"
- "`OrderProcessor.Process()`에서 결제와 배송을 하나의 트랜잭션으로 처리하고 있습니다. 의도적으로 결합한 것인지, 분리 예정인지 궁금합니다."
- "`config.MAX_RETRY = 7`로 하드코딩되어 있습니다. 이 값이 특정 요구사항에서 나온 것인지, 임의 설정인지 확인하고 싶습니다."

### 피해야 할 질문 패턴

- 코드를 읽으면 바로 알 수 있는 것을 묻기 ("이 메서드는 뭘 하나요?")
- 주관적 판단을 전제로 한 질문 ("이 코드가 왜 이렇게 복잡한가요?")
- 한꺼번에 여러 주제를 묻기 (한 질문에 하나의 주제)
