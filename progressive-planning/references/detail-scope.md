# 세부 설계 수준 레이어 가이드

특정 기능, 서브시스템, 디자인 패턴, 모듈 내부 설계에 적용한다.

## Layer 1: 설계 방향

"왜 이 접근법인가"에 집중한다.

### 초안 포함 항목

- **목적**: 이 설계가 해결하는 문제 또는 달성하려는 것
- **설계 의도**: 핵심적으로 지키고자 하는 원칙 (예: 느슨한 결합, 단일 책임, 확장 용이성)
- **접근법 후보**: 고려한 디자인 패턴/아키텍처 2~3개와 각각의 장단점
- **선택한 접근법**: 최종 선택과 그 이유
- **기존 코드와의 관계**: 영향 받는 기존 코드, 호환성 고려사항

### 핵심 질문

> **[핵심]** "제시된 접근법 후보 중 선호하는 방향이 있습니까? 또는 다른 접근법이 있습니까?"
> **[핵심]** "이 설계에서 가장 중요한 품질은 무엇입니까? (예: 성능, 유지보수성, 확장성, 테스트 용이성)"

추가 질문 패턴:
- 해결하려는 문제의 핵심 제약은 무엇인가
- 기존 코드베이스의 컨벤션/패턴과 어떻게 조화시킬 것인가
- 이 설계가 향후 어떤 변경을 수용해야 하는가

---

## Layer 2: 구조 설계

"어떤 구조로 만드는가". Layer 1에서 확정된 접근법의 핵심 구성 영역을 **하나씩** 진행한다.

### 초안 포함 항목

- **핵심 구성요소**: 클래스/모듈/인터페이스와 각각의 책임
- **상호작용 흐름**: 구성요소 간 호출/이벤트/데이터 흐름
- **인터페이스 정의**: 공개 API, 이벤트 시그니처, 프로토콜
- **패턴 적용 방식**: 선택한 디자인 패턴이 구조에 어떻게 반영되는지
- **확장 포인트**: 향후 변경/확장이 예상되는 지점과 그 대응 설계

### 핵심 질문

> **[핵심]** "구성요소 간 책임 분리가 적절합니까? 경계를 다르게 나누고 싶은 부분이 있습니까?"
> "상호작용 흐름에서 우려되는 부분이 있습니까? (순환 의존, 성능 병목 등)"

추가 질문 패턴:
- 구성요소 간 결합도를 어떻게 낮출 것인가 (DI, 이벤트, 인터페이스 등)
- 데이터 흐름 방향이 적절한가 (단방향 vs 양방향)
- 동시성/스레드 안전성이 필요한 구성요소가 있는가
- 테스트 격리를 위해 어떤 경계를 두는가

---

## Layer 3: 구현 명세

"코드로 어떻게 옮기는가". Layer 2의 확정된 구성요소 중 **하나씩** 순서대로 진행한다.

### 초안 포함 항목

- **클래스/메서드 설계**: 시그니처, 접근 제어, 반환 타입
- **데이터 구조**: 필드, 타입, 유효성 조건
- **코드 패턴**: 구체적 구현 패턴 (예: 콜백 등록 방식, 이벤트 버스 구현, 팩토리 로직)
- **에러 처리**: 예외 시나리오와 대응 방식
- **사용 예시**: 이 구성요소를 호출하는 코드 스니펫 (의도를 명확히 전달)

### 핵심 질문

> **[핵심]** "제시된 시그니처와 데이터 구조가 명확하고 완전합니까? 빠진 메서드나 필드가 있습니까?"
> "각 메서드의 사전/사후 조건이 명확합니까? 호출자가 보장해야 할 것은 무엇입니까?"

추가 질문 패턴:
- 에러/예외 시 호출자에게 어떻게 알릴 것인가 (예외 던지기, 오류 코드 반환, null 반환 등)
- 구체적 타입 선택의 이유는 무엇인가 (제네릭 vs 구체 타입, 열거형 vs 문자열, 클래스 vs 구조체 등)
- 성능 핫패스라면 주의할 할당/복사가 있는가 (메모리 풀링, 구조체 복사 등)
- 사용 예시 코드가 실제 사용 시나리오를 정확히 반영하는가

---

## 출력 템플릿

### Layer 1 예시 (설계 방향)

```
## 게임 이벤트 시스템 설계 — Layer 1: 설계 방향

### 목적
게임 내 오브젝트 간 결합도를 낮추고, 이벤트 기반으로 상호작용을 처리하는 시스템 구축.
현재 직접 참조로 연결된 시스템들(UI ↔ GameLogic ↔ Audio)을 분리한다.

### 설계 의도
- 느슨한 결합: 발행자와 구독자가 서로를 모른다
- 타입 안전: 이벤트 타입별로 컴파일 타임 검증
- 성능: 프레임당 이벤트 처리에 GC 할당 최소화

### 접근법 후보
1. **Observer 패턴 (직접 구독)**
   - 장점: 단순, 디버깅 쉬움
   - 단점: 구독/해지 관리 번거로움, N:M 관계에서 복잡
2. **Event Bus (중앙 디스패처)**
   - 장점: 완전한 디커플링, 구독/해지 일원화
   - 단점: 이벤트 추적 어려움, 타입 안전성 확보 필요
3. **Reactive Streams (UniRx 등)**
   - 장점: 체이닝, 필터링, 스케줄링 내장
   - 단점: 학습 곡선, 외부 의존성

### 선택한 접근법
Event Bus — 완전한 디커플링이 핵심 요구사항이며, 제네릭 기반으로 타입 안전성 확보 가능.

### 기존 코드와의 관계
- `GameManager.cs`의 직접 참조 호출을 이벤트 발행으로 전환
- 기존 `UIManager.OnScoreChanged()` 등 콜백을 이벤트 구독으로 마이그레이션
```

### Layer 2 예시 (구조 설계)

```
### Event Bus 시스템 — Layer 2: 구조 설계

#### 핵심 구성요소
1. EventBus (싱글톤)
   - 책임: 이벤트 등록/해지/디스패치 중앙 관리
   - 인터페이스: Subscribe<T>(), Unsubscribe<T>(), Publish<T>()
2. IGameEvent (인터페이스)
   - 책임: 모든 이벤트의 기반 타입, 타입 안전 보장
3. EventBinding<T> (제네릭 구조체)
   - 책임: 구독 정보(콜백 + 우선순위) 보유, 해지 시 자동 정리

#### 상호작용 흐름
발행자 → EventBus.Publish<ScoreChangedEvent>(evt)
  → EventBus가 ScoreChangedEvent 구독 목록 조회
  → 우선순위 순으로 콜백 호출
  → 구독자(UIManager 등)가 이벤트 수신

#### 패턴 적용 방식
- Event Bus 패턴: EventBus가 중재자 역할, 발행자/구독자 직접 참조 없음
- 제네릭 활용: Dictionary<Type, List<Delegate>> 기반 타입별 구독 관리

#### 확장 포인트
- 이벤트 필터링: 조건부 구독 (예: 특정 플레이어의 이벤트만)
- 이벤트 히스토리: 디버그 모드에서 발행 이력 기록
```

### Layer 3 예시 (구현 명세)

```
#### EventBus — Layer 3: 구현 명세

##### 클래스/메서드 설계
public class EventBus
  - static EventBus Instance { get; }
  - void Subscribe<T>(Action<T> callback, int priority = 0) where T : IGameEvent
  - void Unsubscribe<T>(Action<T> callback) where T : IGameEvent
  - void Publish<T>(T evt) where T : IGameEvent
  - void Clear() — 모든 구독 해지 (씬 전환 시)

##### 데이터 구조
- _subscriptions: Dictionary<Type, SortedList<int, List<Delegate>>>
  - Key: 이벤트 타입
  - Value: 우선순위(int) → 콜백 리스트

##### 코드 패턴
- Publish 시 리스트 복사 후 순회 (순회 중 구독/해지 안전)
- Subscribe 시 중복 등록 방지 (같은 콜백 2회 등록 무시)
- 콜백에서 예외 발생 시 catch 후 다음 콜백 계속 호출, 에러 로그 출력

##### 에러 처리
- 구독자 없는 이벤트 Publish: 경고 로그 (에러 아님)
- null 콜백 등록 시도: ArgumentNullException

##### 사용 예시
// 구독
EventBus.Instance.Subscribe<ScoreChangedEvent>(OnScoreChanged);

// 발행
EventBus.Instance.Publish(new ScoreChangedEvent { NewScore = 100 });

// 해지 (OnDestroy에서)
EventBus.Instance.Unsubscribe<ScoreChangedEvent>(OnScoreChanged);
```

### 최종 계획서 구조

```
# [주제] — 점진적 설계서

## 개요
- 목적: [해결하는 문제]
- 강도: [사용된 질문 강도]
- 선택한 접근법: [디자인 패턴/아키텍처]

## Layer 1: 설계 방향
[Phase 1 확정 내용 — 의도, 후보 비교, 최종 선택]

## Layer 2: 구조 설계
### [구성요소 영역 1]
[Phase 2 확정 내용 — 책임, 흐름, 인터페이스]
### [구성요소 영역 2]
[Phase 2 확정 내용]

## Layer 3: 구현 명세
### [구성요소 1]
[Phase 3 확정 내용 — 시그니처, 데이터, 패턴, 예시]
### [구성요소 2]
[Phase 3 확정 내용]

## 열린 질문
- [아직 결정되지 않은 사항들]

## 설계 결정 기록
| 결정 | 선택 | 이유 | 대안 |
|------|------|------|------|
```
